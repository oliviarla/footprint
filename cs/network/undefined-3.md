# 서버 네트워크

## 네트워크 설정 및 확인

### 네트워크 필수 정보 설정 방법

* IP 주소, 서브넷, 게이트웨이, DNS 정보를 설정하는 방법을 알아본다.

#### CentOS

* `/etc/sysconfig/network-scripts` 경로에 인터페이스 설정 파일과 인터페이스 제어용 스크립트들이 존재한다.
* 인터페이스 설정 파일은 `ifcfg-eth0` 과 같은 이름을 가지며, 다음 항목들을 가진다.

<table><thead><tr><th width="173.359375">NAME</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>ONBOOT</td><td>부팅 시 인터페이스를 활성화시킬 것인지 결정(yes/no), 비활성화 상태이면 리부팅 시 네트워크에 연결되지 않는다.</td></tr><tr><td>BOOTPROTO</td><td>부팅 시 사용할 프로토콜(none, dhcp, static)</td></tr><tr><td>IPADDR</td><td>IP 주소</td></tr><tr><td>NETMASK</td><td>서브넷 마스크 예: 255.255.255.0</td></tr><tr><td>PREFIX</td><td>서브넷 마스크(비트 값으로 표기) 예: 24</td></tr><tr><td>GATEWAY</td><td>게이트웨이 주소</td></tr><tr><td>DNS1</td><td>주 DNS 정보 입력</td></tr><tr><td>DNS2</td><td>보조 DNS</td></tr></tbody></table>

* 변경된 네트워크 인터페이스 설정 파일을 적용하려면 네트워크 서비스를 재시작하거나 인터페이스를 재시작해야 한다.
  *   네트워크 재시작은 다음 명령을 사용해야 한다. 원격 상에서 잠시동안 지연이 발생하고 끊기지는 않는다. 단, 재시작이 오래 걸리는 경우에서는 원격 접속이 끊길 수 있다.\


      ```
      systemctl restart network.service
      ```
  *   특정 인터페이스만 종료하고 재시작할 수 있다. 이 과정 중에 네트워크가 끊기므로 다른 인터페이스로 접속하거나 콘솔 상태에서 작업해야 한다.\


      ```
      ifdown ifcfg-eth0
      ifup ifcfg-eth0
      ```

#### Ubuntu

* `/etc/network/interfaces` 설정 파일에 접근하여 인터페이스를 설정할 수 있다. CentOS와 달리 하나의 파일에 모든 인터페이스를 정의한다.
*   네트워크 서비스를 시작/정지/재시작하는 명령은 다음과 같다.

    ```
    /etc/init.d/networking start
    /etc/init.d/networking stop
    /etc/init.d/networking force-reload
    ```

### 설정된 정보들 확인 방법

#### CentOS & Ubuntu

* `ifconfig` 명령을 이용해 현재 활성화된 인터페이스 정보를 확인할 수 있다.
* 직접 설정한 IP 주소, 서브넷, 게이트웨이와 같은 정보는 물론 MTU 크기, 송수신되는 패킷 수, 에러 패킷 등의 다양한 정보를 간단히 확인할 수 있다.
* `ifconfig` 명령이 `command not found` 로 실행되지 않는다면, 네트워크 관련 `net-tools` 패키지가 기본 패키지에서 제외되었을 수 있으므로 추가로 설치해주어야 한다.
* `ip address` 명령도 `ifconfig`와 유사하게 네트워크 정보를 확인할 수 있다.

## 라우팅 테이블

### 디폴트 라우팅

* 네트워크 정보를 설정할 때, IP, 서브넷 마스크, 기본 게이트웨이의 IP 주소를 입력하는데, 이때 라우팅 정보를 별도로 설정하지 않으면 디폴트 라우팅이 라우팅 테이블에 자동으로 등록된다.
* 디폴트 라우팅을 이용해 네트워크 기본 설정을 마치면 내/외부 네트워크와 원활하게 통신 가능하다.
* 한 서버에 네트워크 어댑터를 두 개 이상 사용하면 각 네트워크 통신을 위해 라우팅 테이블을 조정해야 한다. 여러 네트워크 어댑터에 모두 디폴트 게이트웨이 설정을 하면 통신이 되지 않으므로, 라우팅 테이블을 수정해 어떤 네트워크 인터페이스를 사용해 패킷을 전송할 지 명시해주어야 한다.

<figure><img src="../../.gitbook/assets/image (180).png" alt=""><figcaption></figcaption></figure>

### 구성 항목

* 목적지 네트워크, 서브넷
  * 서버가 통신하려는 목적지 IP 주소에 맞는 라우팅을 선택하는 기준이 된다.
  * 예를 들어 서버가 통신하려는 목적지가 10.10.20.10일 때 라우팅 테이블의 목적지 네트워크, 서브넷이 10.10.20.0/24 이면 해당 라우팅을 적용한다.
* 게이트웨이
  * 선택한 목적지로 가기 위해 서버에서 선택하는 넥스트 홉
  * 목적지가 로컬 네트워크이면 Connected 라고 표현되고, 원격 네트워크이면 해당 네트워크의 게이트웨이로 설정된다.
  * 서버에 여러 NIC이 있으면 원하는 NIC의 게이트웨이로 지정해줘야 한다.
* 인터페이스
  * 서버의 NIC 카드를 의미하며, 어떤 물리적인 경로로 패킷을 내보낼지 설정한다.
  * 게이트웨이의 IP 주소 대역에 속하는 인터페이스를 지정해야 한다.
* 우선순위
  * 동일한 라우팅 테이블이 두 개 이상 존재할 때 어떤 테이블을 선택할 지 정하는 값이다.
  * 값이 낮을수록 우선순위가 높아진다.
  * 우선순위를 활용해 actie-standby 형태의 게이트웨이를 구성할 수 있다.

<figure><img src="../../.gitbook/assets/image (181).png" alt=""><figcaption></figcaption></figure>

### 리눅스 서버의 라우팅 확인 및 관리

* 라우팅 테이블 확인
  * `ip route`
  * `netstat -r`
* 라우팅 테이블 추가
  * `route add {-host | -net} Target[/prefix] [gw GW] [metric M] [[dev] if]`
  * 예를 들어 `route add -host 10.10.10.10 gw 10.1.1.1` 로 라우팅 테이블을 설정하면 10.10.10.10 서버가 목적지인 경우  10.1.1.1로 라우팅하라는 의미이다.
* 라우팅 테이블 제거
  * `route del {-host | -net} Target[/prefix] [gw GW] [metric M] [[dev] if]`
  * 별도로 입력한 라우팅 테이블이 모두 삭제되더라도 디폴트 라우팅이 남아있다면 해당 경로로 외부 네트워크와 통신할 수 있다.
* 디폴트 라우팅을 추가/삭제 시에는 `route add/del default ...` 형태로 사용하면 된다.
* 영구적 라우팅 테이블 설정 시, 별도 파일에 라우팅 설정을 입력해야 한다.
  * **CentOS**
    * `/etc/sysconfig/network-scripts/route-장치명` 파일을 생성해 설정하면 된다.
    * 라우팅 테이블을 여러 개 설정하는 경우 각 항목 뒤에 숫자를 붙이면 된다.
    *   다음은 라우팅 테이블 설정 예제이다.

        ```
        ADDRESS0=10.10.10.0
        NETMASK0=255.255.255.0
        GATEWAY0=10.1.1.1
        ADDRESS1=10.10.20.0
        NETMASK1=255.255.255.128
        GATEWAY1=10.1.1.1
        ```
  * **Ubuntu**
    * `/etc/network/interfaces` 설정 파일에 일반 라우팅 테이블 설정 명령을 추가한 후 서버를 재부팅하거나 네트워크 서비스를 다시 시작하여 적용한다.
    *   다음은 라우팅 테이블 설정 예제이다.

        ```
        auto eth0

        iface eth0 inet static
            address 10.1.1.6
            netmask 255.255.255.0
            gateway 10.10.10.1
            dns-nameserver 219.250.36.130

        # 라우팅 테이블 추가
        up route add -net 10.10.10.0 netmask 255.255.255.0 gw 10.1.1.1
        ```

## 리눅스 네트워크 명령어

#### ping

* IP 네트워크를 통해 특정 목적지까지 네트워크가 잘 동작하는지 확인하는 명령어
* 상대 호스트가 살아있는지 확인하고, 두 호스트 간의 라우팅 경로가 정상적으로 구성되어 있는지 체크할 수 있다.
* ICMP(Internet Control Message Protocol)을 사용하여 여러 가지 네트워크 상태를 파악한다.

```
ping [option] <address>
```

* 옵션의 종류는 다음과 같다. 옵션을 주어 ping을 보내는 것을 확장 ping이라고 부르며, 출발지 주소를 옵션을 주어 지정하는 경우 Source ping이라고 부른다.

| NAME          | DESCRIPTION                                                                                                                                                         |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -c count      | <p> ping을 보내는 패킷(ECHO_REQUEST)을 몇 번 보내고 종료할 것인지를 지정<br>기본 설정은 강제로 정지(CTRL+C)할 때까지 패킷을 지속적으로 보낸다.</p>                                                                |
| -i interval   | <p>패킷을 보내는 시간 간격</p><p>기본 설정값은 1초</p><p>슈퍼 유저의 경우, 0.2 이하로 설정 가능</p>                                                                                                |
| -I interface  | <p>패킷을 보낼 때, 출발지 주소를 지정</p><p>실제 IP 값을 지정하거나 인터페이스 이름을 지정하면 출발지 주소가 변경된다.</p><p>이 옵션을 사용하지 않는 경우, 라우팅 테이블에 의해 나가는 인터페이스(Outgoing-Interface)의 IP 주소가 출발지 주소가 된다.</p> |
| -s packetsize | <p>패킷 크기를 지정</p><p>기본 설정값은 56바이트(8바이트의 ICMP 헤더가 추가로 붙어 64바이트를 송신)</p>                                                                                               |

* 목적지 단말이 잘 살아 있고 중간 경로에 문제가 없더라도 실제 서비스를 위해 사용되는 서비스 포트가 정상 상태인지 ping만으로는 확인할 수 없다.
* 출발지와 목적지 사이에 방화벽과 같은 보안 장비에서 막히지 않는지, 목적지 운영체제에서 운영체제 방화벽이 동작해 차단하는 것은 아닌지, 목적지에서 서비스하기 위해 정상적으로 서비스 포트가 오픈되지 않았는지 추가로 확인해야 한다.

#### traceroute

* 출발지부터 통신하거나 목적지까지의 네트워크 경로를 확인할 때 사용하는 네트워크 명령
* 출발지 pc에서 목적지까지의 라우팅 경로를 확인할 수 있고 목적지까지의 통신에 문제가 있을 때, 어느 구간부터 문제가 발생했는지 찾아낼 수 있다.
* 목적지까지의 네트워크 응답 시간이 느린 경우, 어느 구간에서 응답 시간이 느려지는지도 알아낼 수 있다.
* IP 헤더의 TTL(Time To Live) 필드를 1부터 1씩 증가시키면서 목적지에 도달할 때까지 패킷을 반복적으로 전송하면서 경로를 추적한다.
* IP 헤더인 3계층 정보에 의한 경로 추적이므로 2계층 이하의 스위치 장비 추적은 불가능하다.
* 서버 1 <-> 서버 2 간의 경로가 서로 동일하지 않아 비대칭 경로인 경우, traceroute를 각각 수행한 결과값으로 경로를 검증해야 한다.

<figure><img src="../../.gitbook/assets/image (182).png" alt=""><figcaption></figcaption></figure>

* 단말의 인터페이스가 두 개 이상인 경우에도 라우팅에 따라 들어오는 인터페이스와 나가는 인터페이스가 달라 통신이 불가능할 수 있다. 이 경우에도 traceroute를 각각 수행하여 정상적으로 보내지는지 확인해야 한다.
* 옵션의 종류는 다음과 같다.
  * traceroute 명령으로 서비스를 위한 서비스 포트가 정상적으로 열리는지 확인하려면 `-s` 옵션을 주면 된다.

| NAME                             | DESCRIPTION                                      |
| -------------------------------- | ------------------------------------------------ |
| -I, --icmp                       | ICMP 기반으로 traceroute 수행                          |
| -T, --tcp                        | TCP SYN으로 traceroute를 수행하면 기본 서비스 포트는 80         |
| -n                               | 결과 출력 시 IP 주소를 도메인이 아닌 숫자 형식으로 표시 (도메인 리졸브 미 수행) |
| -p port, --port=port             | 특정 포트를 지정해 traceroute 수행                         |
| -s src\_addr, --source=src\_addr | 패킷이 나가는 인터페이스가 아닌 별도 IP로 출발지 IP를 지정              |



* 보안상의 이유로 중간에 있는 보안 장비에서 icmp 메시지나 UDP 패킷을 차단하는 경우나 중간의 라우터 장비에서 자신의 IP가 노출되는 것을 막기 위해 `traceroute icmp` 메시지에 대해 응답하지 않을 때는 응답 시간이 아닌 \*\*\*로 표기한다.

#### tcptraceroute

* 서비스에 문제가 생겼을 때 중간 경로에서 차단되었는지, 최종 목적지에서 차단되었는지, 목적지 단말에서 서비스를 제대로 오픈하지 못했는지 확인할 수 있는 명령어

```
tcptraceroute [option] address [service port]
```

* 옵션의 종류는 다음과 같다.

| NAME              | DESCRIPTION                                      |
| ----------------- | ------------------------------------------------ |
| -n                | 결과 출력 시 도메인이 아닌 숫자 형식으로 IP 주소를 표시 (도메인 리졸브 미 수행) |
| -s source address | 출발지 IP 주소를 지정                                    |
| destination port  | 서비스 포트 지정                                        |

#### netstat

* 서비스 포트, 네트워크 연결 등 다양한 네트워크 상태 확인 시에 사용되는 명령어
* 라우팅 테이블이나 인터페이스 패킷 통계 정보 확인도 가능하다.
* 옵션의 종류는 다음과 같다.
  * `-ant` 옵션을 사용하면 TCP에 대한 모든 연결과 수신 대기 정보를 숫자로 출력하게 된다.

| NAME             | DESCRIPTION                          |
| ---------------- | ------------------------------------ |
| -a, --all        | 모든 연결과 수신 대기 포트 표시                   |
| -n, --numeric    | 주소와 포트 번호를 숫자 형식으로 표시(예: http → 80 ) |
| -r, --route      | 라우팅 테이블 표시                           |
| -i, --interfaces | 인터페이스별 입출력 패킷 통계                     |
| -s, --statistics | 네트워크에 통계 데이터 출력                      |
| -p, --programs   | PID와 프로그램 이름 출력                      |
| -t, --tcp        | TCP만 출력(TCP, TCPv6)                  |
| -4/-6            | IPv4나 IPv6에 대해 출력                    |

#### ss

* 소켓 정보를 확인할 수 있는 명령어
* netstat 명령어보다 더 다양한 옵션을 제공하고 커널 스페이스에서 정보를 가져오므로 빠르다.
* 특정 서비스가 어떤 프로세스에 의해 점유되고 있는지 쉽게 알아낼 수 있다.

```
ss [option] [filter]
```

* 옵션의 종류는 다음과 같다.
  * `-it4` 옵션과 `state connected` 필터를 사용하면 TCP 상태가 커넥티드인 연결에 대한 정보만 확인할 수 있다.

| NAME                   | DESCRIPTION                    |
| ---------------------- | ------------------------------ |
| -a                     | 화면에 전체 소켓을 표시                  |
| -l                     | 화면에 LISTENING 상태의 소켓만 표시       |
| -i                     | 소켓에 대한 자세한 정보                  |
| -p                     | 현재 소켓에서 사용 중인 프로세스 표시          |
| -n                     | 서비스 명이 아닌 실제 포트 번호로 서비스 포트를 표기 |
| -4, -6, --ipv4, --ipv6 | IPv4, IPv6에 대한 소켓만 각각 화면에 표시   |
| -s                     | 프로토콜별 통계 표시                    |
| -t, -u                 | TCP/UDP에 대한 소켓만 각각 화면에 표시      |

* state로 필터링할 수 있는 상태 값은 다음과 같다.
  * established, syn-sent, syn-recv, fin-wait-{1,2}, time-wait, closed, close-wait, last-ack, listen, closing

#### nslookup

* DNS에 다양한 도메인 관련 내용을 질의해 결과를 확인하는 명령어
* 기본적으로 운영체제에 설정했던 네트워크 설정 정보를 이용해 DNS 서버 주소로 질의를 보낸다.
* 옵션값으로 질의하려는 DNS 서버를 변경하여, 특정 도메인의 변경된 설정값이 외부 DNS로 잘 전파되었는지 확인할 때 사용할 수 있다.
* 기본적으로 DNS 레코드 타입 중 A 레코드에 대한 값을 질의하고 결과를 받게 된다. 다른 레코드 정보 확인을 위해서는 `set type=<record_name>` 옵션을 이용해야 한다.

#### telnet

* 원격지 호스트에 터미널 연결을 하기 위해 사용되는 표준 프로토콜이다.
* 평문을 사용하므로 보안성이 약하다. 공개 키 방식의 암호화를 사용한 SSH(Secure SHell) 사용을 권장한다.
* 특정 서비스가 열려있는지 확인하는 용도 혹은 테스트 용도로는 적합하다.
* 텔넷으로 서비스 접근이 불가능한 이유는 보통 다음과 같이 특정할 수 있다.
  * 도착지 단말이 꺼져 있거나 네트워크에 정상적으로 연결되어 있지 않은 경우
  * 도착지 단말의 네트워크 설정에 문제가 있는 경우
    1. 출발지로부터 해당 서비스가 동작 중인 서버까지의 경로가 정상적으로 잡혀 있지 않은 경우
    2. 출발지로부터 해당 서비스가 동작 중인 서버까지의 경로상 보안 장비 등에 의해 차단된 경우
    3. 도착지 단말의 방화벽이나iptables와 같은 보안 기능에서 차단된 경우
    4. 도착지 단말이 정상적으로 서비스가 열려 있지 않은 경우(서비스 포트가 Listening 상태가 아니거나 서버 서비스가 구동되지 않았거나 다른 포트로 매핑되어 서비스가 올라온 경우)

#### tcpdump

* 네트워크 인터페이스로 오가는 패킷을 캡쳐하는 기능이다.
* 장애 처리나 패킷 분석이 필요할 때 자주 사용된다.
* 필터링 옵션은 and, or를 이용해 조합할 수 있다. not 키워드를 이용해 특정 조건을 제외할 수도 있다.
  * ex) `tcpdump -i eth0 not tcp port 22 and host 172.16.10.10`
* tcpdump로 캡쳐해야 할 패킷이 많으면 파일에 저장한 후 와이어샤크로 불러오면 보기 편하게 분석할 수 있다.

| NAME               | DESCRIPTION                                                         |
| ------------------ | ------------------------------------------------------------------- |
| -i \<interface>    | 패킷을 캡처할 인터페이스                                                       |
| src \<IP address>  | 출발지 IP 주소를 지정해 필터링                                                  |
| dst \<IP address>  | 목적지 IP 주소를 지정해 필터링                                                  |
| host \<IP address> | 출발지/목적지와 상관없이 IP 주소를 지정해 필터링                                        |
| -n                 | <p>이름으로 표기되는 호스트 네임을 실제 IP 주소로 표기<br>(예: Localhost → 127.0.0.1)</p> |
| -nn                | <p>이름으로 표기되는 서비스 포트를 실제 포트 번호로 표기<br>(예: http → 80)</p>             |
| src port \<port>   | 출발지 포트를 지정해 필터링                                                     |
| dst port \<port>   | 목적지 포트를 지정해 필터링                                                     |
| port \<port>       | 출발지/목적지와 상관없이 tcp 포트를 지정해 필터링                                       |
| tcp / udp          | tcp 또는 udp만 필터링                                                     |
| -c \<count>        | tcpdump로 출력할 결과의 개수 지정                                              |
| -w \<filename>     | tcpdump의 결과를 화면에 출력하지 않고 파일명으로 저장                                   |
| -r \<filename>     | 파일로 저장한 tcpdump 파일을 화면에 출력                                          |

## iptables로 방화벽 확인

### iptables 소개

* netfilter라는 리눅스 커널 모듈로 실제 필터링이 이뤄진다. iptables를 비롯해 비슷한 역할을 하는 firewalld, UFW는 모두 netfilter를 사용한 사용자 단 애플리케이션일 뿐이다.

> CentOS 7 이후 버전은 firewalld가 활성화되어있어 firewalld 서비스를 비활성화하고 iptables를 설치해야 한다.

* **서버에서 허용하거나 차단할 IP, 서비스 포트에 대한 정책**을 정의한다.
* 서버 기준의 트래픽 구간(INPUT, OUTPUT, FORWARD)별로 **정책 그룹**을 만들어 관리된다.
* **체인**이란 개별 정책의 방향성에 따라 구분한 그룹이고, 체인을 역할별로 구분한 그룹을 **테이블**이라 한다.
* Filter 테이블, NAT 테이블, Mangle 테이블, Raw 테이블, Security 테이블이 존재한다.
  *

### Filter 테이블

* 리눅스의 호스트 방화벽은 **Filter 테이블을 통해 트래픽을 제어**한다.
* Filter 테이블 구조는 다음과 같다.

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

* Filter 테이블
  * iptables에서 패킷을 허용하거나 차단하는 역할을 선언하는 영역
* INPUT,OUTPUT,FORWARD 체인
  * 호스트 기준으로 호스트로 들어오거나(INPUT), 호스트에서 나가거나(OUTPUT), 호스트를 통과할(FORWARD) 때 사용되는 정책들의 그룹
  * 패킷의 방향성에 따라 각 체인에 정의된 정책이 적용된다.
* Match
  * 제어하려는 패킷의 상태 또는 정보 값의 정의
  * 정책에 대한 조건
  * 상단의 정책이 하단보다 먼저 적용되는 탑다운 방식으로 적용된다. 따라서 **어느 위치에 정책을 설정하는지가 중요**하다.
* Target
  * 패킷이 iptables에 정의한 정책과 일치할 때 어떤 행동을 취할 지에 대한 정의이다.
  * 기본적으로 ACCEPT(허용), REJECT(차단하면서 응답 메시지 전송), DROP(폐기)이 많이 사용된다.
  * syslog에 로깅를 하기 위한 LOG, NAT을 위한 SNAT, DNAT 등 다양한 타깃 설정이 가능하다.
  * Match(조건)와 일치하는 패킷을 허용할 지, 차단할 지에 대한 패킷 처리 방식

### 방화벽 관리

> 명령어를 사용해 방화벽 정책을 변경하는 경우 재시작 시 정책이 초기화된다. 영구적으로 정책을 적용하려면 /etc/sysconfig/iptables 내용을 변경해야 한다.

* 방화벽 정책 확인
  *   체인별로 정의된 정책을 확인할 수 있다.

      ```
      iptables -L
      ```
  *   체인별로 정의된 정책을 줄 번호와 함께 확인할 수 있다.

      ```
      iptables -L --line-number
      ```
  *   실제 정의된 정책을 확인할 수 있다.

      ```
      iptables -S
      ```
  *   정책이 이미 존재하는지 확인할 수 있다.

      ```
      iptables -C INPUT -p tcp --dport 21 -j ACCEPT
      ```
* 정책 추가
  *   -A 옵션과 함께 체인, 대상 프로토콜과 인터페이스, 서비스 포트 등을 명시한 정책을 정의한다. 정책은 맨 마지막 줄에 삽입된다.

      ```
      iptables -A <chain> -p <protocol> --dport <port> -j <policy>
      ```
  *   다음 예제는 TCP 80 포트를 열어 웹 서비스를 제공하기 위한 정책을 추가하는 명령이다.

      ```
      iptables -A INPUT -p tcp --dport 80 -j ACCEPT
      ```
  *   -I 옵션과 함께 체인, 대상 프로토콜과 인터페이스, 서비스 포트 등을 명시한 정책을 원하는 줄 번호 위치에 정의한다.

      ```
      iptables -I <chain> <line number> -p <protocol> --dport <port> -j <policy>
      ```
* 정책 제거
  *   -D 옵션과 함께 체인, 대상 프로토콜과 인터페이스, 서비스 포트 등을 명시한 정책을 입력한다.

      ```
      iptables -D <chain> -p <protocol> --dport <port> -j <policy>
      ```
  *   -F 옵션으로 iptables의 모든 정책을 제거할 수 있다.

      ```
      iptables -F
      ```

### 방화벽 로그 확인

* 기본적으로 iptables 정책에 의해 차단되거나 허용된 내용은 `/var/log/messages` 에 남게 된다.
* 해당 로그 파일은 여러 리눅스 로그들이 혼재되어 있으므로, rsyslog.conf 파일을 작성 후 서비스를 시작하여 별도 로그 파일에 로깅할 수 있다.
* ```
  echo 'kern.* /var/log/iptables.log' >> /etc/rsyslog.conf

  systemctl restart rsyslog.service

  iptables -I INPUT -j LOG --log-level 4 log-prefix '## iptables-log ##'

  tail -f /var/log/iptables.log
  ```
*   iptables 정책마다 통과하는 패킷과 바이트 수를 확인할 수 있다.

    ```
    iptables -L -v
    ```

**출처**

* 알라딘 eBook \<IT 엔지니어를 위한 네트워크 입문>
