# Serverless Function

## 서버리스 플랫폼 동작 원리

* AWS 람다, Azure 펑션 등 플랫폼에서는 CLI를 통해 코드를 업로드하면 클라우드 속 어디선가 코드가 실행된다.
* 따라서 사용자가 직접 애플리케이션을 컴파일하고 컨테이너 이미지를 빌드하고 YAML파일로 리소스를 정의하지 않아도 된다.
* Kubeless를 사용하면 소스 코드 파일을 펑션으로 배치하면 이를 컨트롤러가 관리해주게 된다. (현재는  Kubeless를 maintain 하고 있지 않아 다른 도구를 사용해야 할 것이다.)
* 펑션 실행은 CLI를 통해 직접 제어할 수도 있고, 트리거를 만들어 HTTP 요청을 받아 실행할 수도 있고, 메시지 큐를 구독하게 하거나 주기적으로 실행할 수 있다.
* 코드를 입력받고 컨테이너로 패키징한 후 코드를 실행할 여러 트리거들을 만든다.

<figure><img src="../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

## 서버리스 펑션 동작시키기

* 구체적인 과정은 다음과 같다.
  * kubeless 리소스를 배치하여 컨트롤러를 파드로 배치하고, 펑션 정의, 펑션을 실행하는 트리거 정의를 CRD로 등록한다.
  * kubeless CLI를 파드로 실행한다.
  * 서버리스 펑션을 배치하면 컨트롤러가 컨피그맵과 파드를 하나씩 가진 디플로이먼트를 생성한다.
    * 서버리스 펑션은 이벤트의 상세 정보, 펑션 자체의 컨텍스트 정보를 인자로 받고, 수행이 끝나면 문자열을 반환한다.
    * 서버리스 펑션을 만들 때에는 전체 프로젝트 구조를 압축한 zip 파일 혹은 단일 파일을 업로드하면 된다.
  * Kubeless는모든 런타임 플랫폼에 빌드 도구가 들어있는 초기화 컨테이너 이미지를 만들어두어, 컨피그맵 볼륨에서 소스 코드를 가져와 애플리케이션을 빌드하고 빌드된 바이너리를 공디렉토리 볼륨에 복사한다. 이후 애플리케이션 컨테이너가 바이너리를 실행한다.
* 트리거를 생성하면 트리거가 파드에 대응하는 서비스에 요청을 보내준다. 이 때 트리거는 HTTP 요청, 메시지 큐, 스케줄 등이 해당된다.
* 애플리케이션 파드와 동일하게 스케일링이 가능하며, 파드 간 로드밸런싱도 이뤄진다. 이 파드는 평범한 쿠버네티스 리소스이므로 별도의 계층이 관리할 필요가 없이 기존 쿠버네티스에 잘 융합되어 동작한다.
* 프록시를 배치해  HTTP 요청으로 펑션을 호출하도록 할 수도 있고,  직접 명령어를 이용해 펑션을 호출할 수도 있다.
* 인그레스 규칙과 인그레스 컨트롤러를 사용해 파드에서 실행되는 웹 애플리케이션과 서버리스 파드를 외부에 노출시키면, 언뜻 보면 같은 시스템에서 돌아가는 것 처럼 제공할 수 있다.
* 서버리스 펑션을 많이 사용하면 펑션 하나하나가 각각 언어 런타임을 읽어들이는 데에 메모리를 소모하므로 파드 축출이 발생하기 쉽다.

## 서버리스 펑션 추상화

* Serverless 프로젝트를 이용하면 서버리스 펑션의 정의를 추상화하고 다른 서버리스 플랫폼과 쉽게 통합할 수 있다.
* 펑션과 트리거를 YAML 파일에 한 번에 정의할 수 있다.
* Serverless의 CLI는 서버리스 펑션의 실제 실행을 프로바이더에게 맡긴다.
* 서버리스 펑션이 정의된 YAML파일을 배치하면 kubeless 펑션과 트리거가 생성된다. 그리고 kubeless 컨트롤러가 파드를 실행하여 사용자 정의 리소스를 관리하게 된다.
