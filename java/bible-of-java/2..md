# 2. 데이터 타입, 변수, 배열

### 프리미티브 타입 종류와 값의 범위 그리고 기본 값 <a href="#undefined" id="undefined"></a>

\- 타입 종류

총 8가지: 논리형(bool), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)

\- 값의 범위

<figure><img src="https://blog.kakaocdn.net/dn/yZZzq/btrKuVtrk2M/FMtBgLAYZd2WbbaGnJtQUk/img.png" alt=""><figcaption></figcaption></figure>

\- 기본값

```
byte             0
short            0
int              0
long             0L
float            0.0f
double           0.0d
boolean          false
char            '\u0000'
```

### 프리미티브 타입과 레퍼런스 타입 <a href="#undefined" id="undefined"></a>

* 프리미티브 타입(기본형)
  * 실제 값을 저장한다.
* 레퍼런스 타입 (참조형)
  * 어떤 값이 저장되어 있는 메모리 주소(객체의 주소)를 저장한다.
  * 선언 시 클래스 이름을 참조 변수의 타입으로 사용

### 리터럴 <a href="#undefined" id="undefined"></a>

* 상수
  * 한번 값을 저장하면 다른 값으로 변경할 수 없는 저장 공간
  * final을 사용하여 선언과 동시에 초기화해야 한다.
  * 리터럴에 의미있는 이름을 붙여코드의 이해와 수정을 쉽게 만듦
* 리터럴
  * 그 자체로 값을 의미하는 것
  * ex) final int MAX\_VALUE= 30; 일 때 30이 리터럴이다. int value= 10; 일 때에도 10이 리터럴이다.

#### 리터럴의 타입

* 정수형과 실수형
  * 2진수일 경우 접두사 '0b'
  * 8진수일 경우 접두사 '0'
  * 16진수일 경우 접두사 '0x'
  * long 타입의 리터럴일 경우 접미사 'l' 또는 'L'&#x20;
  * float 타입의 리터럴에는 접미사 'f' 또는 'F'
  * double 타입의 리터럴에는 접미사 'd' 또는 'D' 이지만 생략 가능
* 문자열
  * 문자 하나를 감쌀 때 작은 따옴표 사용
  * 문자열을 감쌀 때 큰 따옴표 사용
  * 기본형 타입의 값을 string으로 바꿀 때 빈 문자열 ""를 더해주면 됨
  * 기본형 타입 + 문자열 타입 -> 기본형 타입이 문자열 타입으로 변환된 다음에 두 문자열이 더해짐

### 변수 선언 및 초기화하는 방법

> 변수: 값을 저장할 수 있는 메모리 공간

\- 변수 타입을 지정하고 변수 이름을 붙여주어 선언한다.

\- 변수 선언 시, 메모리의 빈 공간에 변수 타입에 알맞는 크기의 저장 공간이 확보되고, 변수 이름을 통해 해당 저장 공간 사용 가능

&#x20;

\- 초기화란, 변수를 사용하기 전 처음으로 값을 지정하는 것

\- 변수를 선언한 후 반드시 초기화 필요

\- 대입 연산자 '='을 이용해 왼쪽에는 변수, 오른쪽에는 할당하려는 값을 지정해 초기화한다.

### 변수의 스코프와 라이프타임 <a href="#undefined" id="undefined"></a>

\- 변수 스코프: 해당 변수가 접근할 수 있는 변수, 객체 그리고 함수의 집합을 의미

\- 변수의 종류

* 인스턴스 변수: 인스턴스가 생성될때 생성된다. 인스턴스 변수의 값을 읽거나 저장하려면 인스턴스를 먼저 생성해야 한다. 각각의 인스턴스마다 고유의 값을 가진다.
* 클래스 변수: 인스턴스 변수에 static을 붙인다. 한 클래스의 모든 인스턴스가 공통된 값을 공유하게 된다. 클래스가 로딩될때 생성 (메모리에 딱 한번만 올라간다.)되고 종료 될 때 까지 유지된다. public을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역 변수가 된다. 인스턴스를 생성하지 않고 클래스이름.클래스변수명 을 통해서 접근가능하다.
* 지역변수: 메서드 내에서 선언되고 메서드 내에서만 사용 가능하다. 메서드가 실행될때 메모리를 할당 받고, 메서드가 종료되면 소멸되어 사용 불가하다.

```
public class test {
    int instVar; // 인스턴스 변수    
    static int classVar; // 클래스 변수
    
    void method() {
    	int localVar; // 지역 변수
    }
}
```

### 타입 변환, 캐스팅 그리고 타입 프로모션 <a href="#undefined" id="undefined"></a>

형변환 (casting)

\- 서로 다른 타입 간의 연산을 수행하기 위해 타입을 일치 시켜야 한다. 이 때 형변환으로 변수나 리터럴의 타입을 변환해야 한다.

\- 기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환 가능

\- 큰 타입에서 작은 타입으로 변환하는 경우 값의 손실이 발생할 수 있다

타입 프로모션

\- 크기가 더 작은 자료형을 더 큰 자료형에 대입할 때, 자동으로 작은 자료형이 큰 자료형으로 변환되는 현상

클래스 간 형변환

\- 다형성이라는 성질을 통해서 두 클래스가 상속 관계일 경우에만 형변환 가능

\- 부모클래스는 명시적인 타입캐스팅 없이 자식 클래스로 사용될 수 있음 (upcasting)

\- 자식클래스는 명시적인 타입캐스팅이 있다면 부모 클래스로 사용 가능 (downcasting)

### 1차 및 2차 배열 선언하기 <a href="#1-2" id="1-2"></a>

**1차원 배열**

배열 선언 후 생성

* 타입\[] 배열이름;
* 배열이름 = new 타입\[배열길이];

배열 선언과 동시에 생성

* 타입\[] 배열이름 = new 타입\[배열길이];

배열의 초기화

* 타입\[] 배열이름 = {배열요소1, 배열요소2, ...};

만약 배열의 선언과 초기화를 따로 진행해야 할 경우나 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우 다음과 같이 초기화

* &#x20;타입\[] 배열이름 = new 타입\[]{배열요소1, 배열요소2, ...};

**2차원 배열**

배열 선언

* 타입\[]\[] 배열이름;
* 타입 배열이름\[]\[];
* 타입\[] 배열이름\[];

배열 선언과 동시에 초기화

타입 배열이름\[열의길이]\[행의길이] = {

&#x20;   {배열요소\[0]\[0], 배열요소\[0]\[1], ...},

&#x20;   {배열요소\[1]\[0], 배열요소\[1]\[1], ...},

&#x20;   {배열요소\[2]\[0], 배열요소\[2]\[1], ...},

&#x20;   ...

};

### 타입 추론, var <a href="#var" id="var"></a>

#### 타입 추론

개발자가 변수의 타입을 명시적으로 적어주지 않고도, 컴파일러가 자동으로 대입된 리터럴로 변수의 타입을 추론하는 것

#### var

\- 초기화 값이 있는 지역변수로만 선언 가능

\- 멤버변수, 또는 메소드의 파라미터, 리턴 타입으로 사용이 불가능

\- 컴파일 시점에, 컴파일러가 오른쪽의 초기화값 리터럴로 타입을 추론하여, 바이트 코드로 변경할 때 var 자리에 타입을 명시

\- 어떠한 타입도 아니고, 클래스에서 사용할 수 있는 예약어가 아니므로 변수명으로 사용 가능

\- 중간에 타입 변경 불가

&#x20;

&#x20;

출처

[https://drinkcoldbrew.tistory.com/2](https://drinkcoldbrew.tistory.com/2)

[http://www.tcpschool.com/java/java\_array\_oneDimensional](http://www.tcpschool.com/java/java\_array\_oneDimensional)

[https://catch-me-java.tistory.com/19](https://catch-me-java.tistory.com/19)
