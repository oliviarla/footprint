# JVM의 정의와 메모리 구조

## JVM 메모리 구조

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

#### stack

* 스레드 생성 시 할당된다
* 메서드 실행 관련 정보가 프레임 단위로 저장된다
* 너무 많은 메서드가 호출되어 스택에 쌓이게 되면 흔히 볼 수 있는(?) StackOverFlowError가 발생한다.
* 스택을 생성하거나 동적으로 크기를 확장할 때 메모리가 부족하면 OutOfMemoryError가 발생한다.
* 프레임
  * JVM stack에 생성되는 메서드 관련 정보 저장 단위
  * 메서드가 호출될 때 생성(push)되며 종료되면 소멸(pop)됨
  * 각 프레임에는 런타임에 필요한 메서드 참조를 위해 런타임 상수 풀 참조를 포함
  * 구성 요소
    * Local Variables
      * 매개 변수와 지역 변수를 저장
      * 컴파일 타임에 결정되며  관련 메서드, 클래스 등의 정보와 함께 바이트코드로 제공
      * JVM에 의해 메서드 호출 시 매개 변수(또는 Args)는 지역 변수 배열에 담겨 전달
      * 인스턴스 메서드 호출 시 지역 변수 0은 인스턴스 메서드 객체 참조인 `this`를 전달하는데 사용 하고 1부터 매개변수들이 표현된다
    * Operand Stack
      * 실행 중간 연산 결과 등을 임시로 저장해두는 스택으로 push/pop 명령어에 의해 액세스 가능
      *   JVM은 지역 변수, 필드의 값을 오퍼랜드 스택으로 로딩하는 명령을 제공하며 

          다른 명령들을 통해 오퍼랜드 스택에서 값을 가져와 연산, 결과를 다시 저장함
      * 호출할 메서드에 전달할 매개 변수 전달과 결과를 수신할 때도 사용됨
    * Frame Data
      * 연관된 메서드의 심볼릭 레퍼런스와 메서드 반환에 필요한 정보 저장
      * 예외가 발생한 경우 catch 블록 정보를 제공하는 Exception 테이블 참조 포함

#### Heap

* JVM 실행 시 생성되어 모든 객체의 인스턴스, 배열 등이 할당되는 영역
* 모든 스레드와 공유해 thread-safe하지 않아 문제가 될 수 있다.
* 힙의 크기는 상황에 따라 유동적이며, 순차적일 필요가 없다.
* 공식적으로 GC가 처리되는 유일한 영역

#### Method

* JVM 실행 시 생성되어 모든 스레드에게 공유된다
* 클래스 별 구조나 메타 데이터를 저장
  * 초기화에 사용되는 스페셜 메서드(인스턴스 초기화 메서드, 클래스 초기화 메서드, 런타임에 메서드 시그니처가 결정되는 메서드)
  * 런타임 상수 풀, 필드/메서드 데이터
  * 생성자/ 메서드 코드
* 논리적으로는 힙의 일부이다
* 메서드 영역의 크기는 유동적이다.

#### Native Method Stacks

* JNI, 네이티브 라이브러리 사용 시 데이터가 저장되는 영역

#### PC Register

* 스레드 생성 시 생성/할당되며 현재 실행 중인 명령의 주소를 저장하는 영역
* 레지스터는 프로세서 내에서 자료를 보관하는 빠른 기억 장치
* 저장되는 명령의 주소는 Java 바이트 스트림(바이트코드) 안에 오프셋을 의미
* 자바 메서드의 경우에만 실행 명령의 주소 저장한다. (opcode)
* JNI 메서드는 저장되지 않는다.

#### Stack Memory VS Heap Memory

* 스택 메모리
  * 메서드 실행/완료에 따라 메모리 크기가 변경된다.
  * 메모리 크기는 OS에 의존적이며 보통은 힙보다 작다.
  * 메모리 할당 속도가 매우빠르다.
  * 메모리 할당과 해제는 메서드 호출에 따라 이뤄진다.
  * 스레드 별로 할당되어 thread-safe 하다.
* 힙 메모리
  * Young Generation, Old Generation 같은 메모리 엑세스 기술이 활용된다.
  * 메모리 크기에 제한이 없어 생성된 모든 객체를 저장한다.
  * GC에 의해 메모리가 관리된다.
  * 메모리를 여러 스레드들이 접근하여 thread-safe하지 않다.

### 런타임 상수 풀

* 클래스/인터페이스가 로딩되어 생성될 때 Method 영역에 할당되는 자료구조
* 컴파일 시 \`.class\` 파일에 생성되는 일반 상수 풀의 런타임 표현
* 일반 상수 풀의 데이터를 기반으로 생성되며 스태틱 상수, 스태틱 메서드, 심볼릭 레퍼런스(또는 실제 참조) 등을 포함

#### 상수 풀

* Java 바이트코드에 포함되어 있는 모든 상수 값을 저장하는 심볼(룩업) 테이블 
* .java 파일이 Java 컴파일러에 의해 컴파일 되어 Java 바이트코드로 변환될 때 생성
* 클래스명, 필드명, String/Primitive type 리터럴, 심볼릭 레퍼런스 등이 저장됨
* 컴파일 타임 시점에 알 수 있는 정보들이 저장되며, 런타임 시점에는 런타임 상수 풀로 일부 데이터가 이동한다.
* 상수 풀에서 런타임 상수 풀로 가는 경우
  * 심볼릭 레퍼런스나 String.intern 등 런타임에 달라질 수 있는 데이터
  * 컴파일 타임에 확정되어 런타임에 변경되지 않는 데이터(리터럴 값 등)들을 제외한 데이터

## 자바 메모리 모델

* 자바 멀티 스레드 환경에서 공유되는 메모리 할당과 동작 방식을 정의하는 모델
* 데이터에 대한 가시성, 접근성 등에 대한 명세를 포함한다.
* 최신 플랫폼에서는 최적화 등을 이유로 명령이 순서대로 실행되는 것을 보장하지 않는다.
* 멀티 프로세서는 메인 메모리와 별개인 캐시 메모리를 소유할 수 있다.
* 여러 스레드가 완벽히 동기화된 상태 유지하기는 비용이 많이 든다.

### 메모리 특성

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p>Shared Multiprocessor Architecture</p></figcaption></figure>

* 공유 멀티프로세서 아키텍처
  * CPU 코어마다 L1, L2 캐시가 존재한다.
  * 캐시에 존재하는 내용과 RAM에 존재하는 내용이 동기화되지 않는 상태가 존재할 수 있다.

#### 메모리 일관성

* 서로 다른 스레드가 하나의 데이터에 접근할 때 일관적인 상태를 보장하는 속성
* 여러 스레드가 동일 데이터를 읽을 때 일관적이지 않은 값을 읽는 경우 에러 발생

#### 메모리 가시성

* 멀티스레드 환경에서 한 스레드에서 변경한 값을 다른 스레드에서 언제 보게 될지를 정의한 것
* 어떤 스레드에 의해 값이 변경되었을 때 다른 스레드가 가장 최신 값을 읽을 수 있게 하는 속성

#### final field

* final 필드는 별도의 동기화 처리가 필요 없기 때문에 세이프한 불변 객체 구현을 지원하며  JIT 컴파일러는 레지스터에 최종 캐시 값을 유지할 수 있음
* 스레드 간 레이스 컨디션일 때에도 불변이다.

#### volatile

* 모든 스레드에서 CPU 레지스터가 아닌 메인 메모리로부터 값을 읽고 쓰도록 강제
* 멀티스레드에서 원자성을 보장해주지 않으므로 synchronized, concurrent 패키지의 AtomicXX 등을 사용해야 한다.
* 현대 멀티프로세서 아키텍처는 쓰기 작업을 바로 갱신하지 않고 레지스터에 담아두었다가 한번에 처리한다.

## 메모리 누수

* 필요하지 않은 메모리를 참조해 해제를 하지 못해 발생하는 누수
* 메모리에 할당되어 있지만 실행 코드에서 접근할 수 없는 경우에도 발생
* 시스템 성능을 저하시키고 치명적 에러가 발생할 확률이 높다
* GC를 사용해 메모리가 관리는 되지만 완벽하지 않다
* 참조, 비참조 유형의 객체가 존재
* 참조중인 객체이지만 사용되지 않는다면 메모리 누수가 발생한 것이다.

<figure><img src="../../.gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

### 발생 원인

* static field 객체가 사용되지 않는 경우 누수 발생 가능
* 사용한 리소스를 해제하지 않아 발생할 수 있으므로, try-with-resourcse 혹은 finally 블록을 통해 리소스 해제하도록 한다.
* equals, hashcode 메서드를 재정의하지 않으면 불필요한 참조가 발생할 수 있다.
* 아우터 클래스를 참조하는 이너 클래스가 있을 때 이너 클래스를 사용하려면 항상 아우터클래스를 참조해야 한다. 이때 아우터 클래스를 사용하지 않는다면 누수 발생 가능
  * 아우터 클래스를 참조하지 않는 경우 이너클래스를 static클래스로 구현하면 바깥 클래스에 대한 참조를 가지지 않아 메모리 누수가 발생하지 않는다.
* ThreadLocal 클래스를 사용해 데이터를 스레드별로 사용할 때 명시적으로 값 제거해주지 않으면 참조가 유지되어 누수 발생 가능
  * ThreadLocal.remove() 메서드 호출해 명시적으로 참조 제거 필요

### 메모리 누수 예방

* VisualVM, YourKit 등과 같은 프로파일러를 활용한 모니터링 또는 \`-verbose:gc\` 옵션 사용으로 GC 모니터링
* 참조 객체(java.lang.ref 패키지)를 통해 메모리 누수를 방지한다.
* 벤치마크를 통해 성능 모니터링
*  코드리뷰

### 메모리 최적화 방법

* 컬렉션 사용 시 초기 사이즈 지정해 초기화 하거나, CRUD에 대한 시간 복잡도를 확인해 적절한 컬렉션을 사용
* HashMap 사용시 리사이징이 일어나면 해시값을 다시 조정하기 때문에 이를 고려할 것
* 불변 객체나 캐싱 형태의 구현을 활용해 볼 것
* 박싱/언박싱을 가급적 피할 것
* Stream API 사용시 메모리를 더 사용하거나 성능이 더 느릴 수 있어 주의할 것

## 스레드 상태 및 메모리 확인

### 스레드 덤프

* 스레드 상태 정보를 확인할 수 있다.
* 자바 프로세스의 모든 스레드에 대한 스냅샷을 떠 문제 진단 시 유용하게 사용될 수 있다.
* 일반 텍스트로 작성되어 내용을 파일에 저장한다.
* jstack, JMC, jvisualvm, jcmd, jconsole 등이 있다.

### 힙 덤프

* 특정 순간에 JVM 메모리 상에 있는 모든 객체에 대한 스냅샷을 떠 확인할 수 있다.
* 앱 실행 시 힙 메모리 사용량 분석 가능 
* 메모리 누수, GC 이슈 등을 해결하는 데 활용
* jmap, VisualVM을 사용하거나 `java -XX:+HeapDumpOnOutOfMemoryError <ClassName>` 설정으로 OutOfMemoryError 발생 시 자동으로 힙 덤프를 수행할 수 있다.

### APM & Profiling

* APM
  * 앱의 성능, 가용성 등을 모니터링 또는 관리하는 것
  * 프로파일링보다 한단계 높은 어플리케이션 수준에서 성능을 모니터링, 분석
* 프로파일링
  * 메모리 사용량, 시간복잡도, 특정 명령의 호출 빈도 등을 측정해 분석하는 것
  * 런타임 동안에 어떤 일이 발생하는 지에 대한 정보를 제공
  * APM과 달리 개발자의 코드 레벨에서 성능을 최적화하는 데에 유용
  * Newrelic, VisualVM 등의 툴이 있다
