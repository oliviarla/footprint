# 3장: 람다

## 람다

* 메서드로 전달할 수 있는 익명 함수를 단순화한 것
* 특징
  * 익명: 일반적인 메서드와 달리 이름이 없어, 구현해야 할 코드에 대한 걱정거리가 줄어든다.
  * 함수: 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 발생 가능한 예외 리스트를 포함한다.
  * 전달: 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
  * 간결성: 익명 클래스처럼 불필요한 선언 등의 코드를 작성할 필요가 없다.
* 익명 클래스에서 구현했던 메서드의 바디만 직접 전달하는 것과 비슷하다.

### 람다의 구성

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption><p><a href="https://www.geeksforgeeks.org/java-lambda-expressions-parameters/">https://www.geeksforgeeks.org/java-lambda-expressions-parameters/</a></p></figcaption></figure>

* 파라미터 리스트
  * 람다 바디에서 사용되는 파라미터를 입력받는다.
* 화살표(→)
  * 화살표는 람다의 파라미터 리스트와 바디를 구분한다.
* 람다 바디
  * 람다의 반환값에 해당하는 표현식이다.

### 스타일

* 표현식 스타일
  * `(parameters) -> expression`
  * 람다 표현식에는 return이 함축되어 있으므로 return을 명시적으로 사용하지 않아도 된다.
  * `(String s) -> "Iron Man"` 형태는 파라미터를 입력받아 "Iron Man"을 return하는 람다 식이다.
* 블록 스타일
  * (parameters) -> { statements; }
  * 블록에는 여러 행의 문장을 포함하는 구문이 들어가며, 리턴 타입이 void가 아니라면 return을 명시적으로 사용해야한다.
  * `() -> {}` 형태는 파라미터가 없는 void 람다 식이다.
  * `(Integer i) -> {return "Alan" + i;}` 형태는 파라미터를 입력받아 특정 문자열을 반환하는 람다 식이다.

## 람다 사용하기

* [함수형 인터페이스](3.md#undefined-5)를 입력인자로 받는 경우 람다를 사용할 수 있다.

### 실행 어라운드 패턴

* DB 등의 자원을 처리할 때 자원을 초기화/준비 -> 작업 처리 -> 자원을 정리/마무리 하는 순서로 이뤄진다.
* 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 실행 어라운드 패턴이라고 부른다.
* 아래는 try-with-resources 구문을 사용해 파일에서 한 행을 읽는 코드이다.

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
		return br.readLine(); // 실제 필요한 작업 수행
	}
}
```

* 이제 함수형 인터페이스를 이용해 동작을 전달해보자. 정의한 `BufferedReaderProcessor` 인터페이스를 processFile 메서드의 인수로 전달할 수 있다.

```java
@FuntionalInterface
public interface BufferedReaderProcessor {
	String process(BuffredReader b) throws IOException;
}
```

```java
public String processFile(BufferedReaderProcessor p) throws IOException {
	try (BuffredReader br = new BuffredReader(new FileReader("data.txt"))) {
		return p.process(br);
	}
}
```

* 다양한 동작들을 람다식 형태로 processFile 메서드에 전달할 수 있다.

```java
// 한 행을 처리하는 코드
String oneLine = processFile((BufferedReader br) -> br.readLine());

// 두 행을 처리하는 코드
Strine twoLines = processFile((BuffredReader br) -> br.readLine() + br.readLine());
```

## 함수형 인터페이스

### 개념

* 정확히 **하나의 추상 메서드를 지정**하는 인터페이스
* 여러 디폴트 메서드가 있어도 추상 메서드가 하나뿐이면 함수형 인터페이스다.
* 다음은 함수형 인터페이스의 예시이다.

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}

public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call() throws Exception;
}
```

* 람다 표현식으로 이러한 함수형 인터페이스의 추상 메서드를 구현해 직접 전달할 수 있다.

```java
// 람다로 Runnable의 구현체 생성 가능
Runnable r1 = () -> System.out.println("Hello world 1");

// 익명 클래스 사용해 구현체 생성
Runnable r2 = new Runnable() {
	public void run() {
		System.out.println("Hello World 2");
	}
}

public static void process(Runnable r) {
	r.run();
}
process(r1);
process(r2);
// Runnable 구현체를 미리 생성해두지 않고 바로 만들어 사용 가능
process(() -> System.out.println("Hello Wordl 3"));
```

### 함수형 인터페이스 종류

#### Predicate\<T>

* test라는 추상 메서드를 정의한다.
* test 메서드는 제네릭 형식 T의 객체를 인수로 받아 boolean 값을 반환한다.
* 다음 코드는 Predicate 인터페이스를 구현해 String 객체가 Empty가 아닌 경우를 필터링한다.

```java
public <T> List<T> filter(List<T> list, Predicate<T> p) {
	List<T> results = new ArrayList<>();
	for(T t: list) {
		if(p.test(t)) {
			results.add(t);
		}
	}
	return results;
}

// T 객체를 입력받아 boolean을 반환하도록 한다.
Predicate<String> nonEmptyStringPredicate = (String) -> !s.isEmpty();

// String 리스트 중 Empty가 아닌 String만 필터링한다.
List<String> nonEmpty= filter(listOfStrings, nonEmptyStringPredicate);
```

#### Consumer\<T>

* 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의한다.
* T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있다.
* 다음은 Consumer와 람다를 이용해서 리스트의 모든 항목을 출력하는 예제다.

```java
public <T> void forEach(List<T> list, Consumer<T> c) {
	for (T t: list) {
		c.accept(t);
	}
}

forEach(
	Arrays.asList(1, 2, 3, 4, 5),
	(Integer i) -> System.out.println(i) // Consumer 인터페이스의 accept 메서드를 람다로 구현
);
```

#### Function\<T, R>

* 제네릭 형식 T 객체를 인수로 받아 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의한다.
* 입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 활용할 수 있다.
  * ex) 사과를 입력받아 사과의 무게 정보만 추출, 문자열을 입력받아 문자열의 길이만 추출
* 다음 코드는 String 리스트를 인수로 받아 각 String의 길이를 포함하는 Integer 리스트로 반환한다.

```java
public <T, R> List<R> map(List<T> list, Function<T, R> f) {
	List<R> result = new ArrayList<>();
	for (T t : list) {
		result.add(f.apply(t));
	}
	return result;
}

List<Integer> l = map(
	Arrays.asList("lambdas", "in", "action"),
	(String s) -> s.length()
);
```

#### primitive type을 위한 함수형 인터페이스

* 제네릭 파라미터에는 reference type(참조형)만 입력받을 수 있다.
* 따라서 기본형을 입출력으로 사용할 때 자동으로 박싱 타입으로 변환(오토박싱)하는 과정을 피할 수 있도록 각 primitive type을 위한 함수형 인터페이스를 제공한다.
* 특정 형식을 입력받는 함수형 인터페이스의 경우 IntPredicate, DoublePredicate, LongBinaryOperator , IntFunction 처럼 타입명이 함께 붙는다.

```java
Predicate<Integer> oddNumbers = (Integer i) -> i % 2 != 0;
addNumbers.test(1000);  // int -> Integer로 박싱 과정이 발생

IntPredicate evenNumbers = (int i) -> i % 2 == 0;
evenNumbers.test(1000); // int -> int 그대로 사용하므로 박싱 과정이 발생 x
```

#### 다양한 함수형 인터페이스 정리

<figure><img src="../../.gitbook/assets/image (28).png" alt=""><figcaption><p><a href="https://javaconceptoftheday.com/java-8-functional-interfaces/">https://javaconceptoftheday.com/java-8-functional-interfaces/</a></p></figcaption></figure>

### 함수 디스크립터

* 함수 디스트립터(function descriptor): 람다 표현식의 시그니처를 서술하는 메서드
* 함수형 인터페이스의 추상 **메서드 시그니처**(입력 인자, 반환값 등 메서드의 특성)는 람다 표현식의 시그니처와 동일해야 한다.
* 아래와 같이 함수형 인터페이스의 추상 메서드 시그니처와 람다의 시그니처가 다르다면 유효하지 않은 람다식이 된다. (Predicate는 boolean을 반환해야 하는데, 람다 식에서는 int를 반환하고 있어 메서드 시그니처 불일치!)

```java
Predicate<Apple> p = (Apple a) -> a.getWeight();
```

### @FunctionalInterface

* 함수형 인터페이스임을 가리키는 어노테이션
* 함수형 인터페이스가 아니라면 컴파일 에러가 발생한다.

### 예외 처리

* 아래와 같이 Checked Exception인 IOException을 명시적으로 선언하는 함수형 인터페이스를 만들었다면,  예외를 던질 수 있는 람다를 사용해도 된다.

```java
@FunctionalInterface
public interface BufferedReaderProcessor {
	String process(BufferedReader b) throws IOException;
}

BufferedReaderProcessor p - (BufferedReader br) -> br.readline();
```

* 하지만 자바에서 제공하는 함수형 인터페이스의 경우 Checked Exception을 던지는 동작을 허용하지 않는다.
* 따라서 아래와 같이 람다식 내부에서 try/catch 블록으로 Checked Exception을 처리해주어야 한다.

```java
Function<BufferedReader, String> f = (BufferedReader b) -> { 
    try { 
        return b.readLine();
    } 
    catch (IOException e) {
        throw new RuntimeException(e);
    }
};
```

## 형식 검사, 추론, 제약

### 형식 검사

*



