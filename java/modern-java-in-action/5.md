---
description: 스트림이 지원하는 다양한 연산을 배워보자.
---

# 5장: 스트림 활용

## 필터링

### Predicate 필터링

* filter 메서드는 Predicate(boolean을 반환하는 함수형 인터페이스)를 인수로 받아서 Predicate에서 true를 반환하는 요소만 포함하는 스트림을 반환한다.

```java
List<Integer> numbers = List.of(1,2,4,2,3,5);
numbers.stream()
       .filter(i -> i % 2 == 0)
       .forEach(System.out::println);
```

### 고유 요소만 필터링

* 고유 요소로 이루어진 스트림을 반환하는 distinct메서드도 지원한다.
* 객체의 고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정한다. (equals & hashcode를 잘 정의해하도록 하자..🥲)

```java
List<Integer> numbers = List.of(1,2,4,2,3,5);
numbers.stream()
       .filter(i -> i % 2 == 0)
       .distinct() // 중복 필터링
       .forEach(System.out::println);
```

## 스트림 슬라이싱

* 스트림의 요소를 선택하거나 스킵하는 방법

### Predicate를 이용한 슬라이싱

#### TAKEWHILE

* **데이터가 정렬되어 있고, 특정 조건이 참이 나오면 반복 작업을 중단**하려면 takeWhile()을 이용해 처리할 수 있다.
* filter는 모든 데이터를 검사하며 true인 것만 다음으로 넘어가지만, takeWhile은 조건에 대해 true가 아니게 될 경우 바로 거기서 멈추게 된다.
* 아래 예제는 320 칼로리 미만인 메뉴만 슬라이싱한다.

```java
List<Dish> silcedMenu = specialMenu.stream()
                                   .takeWhile(dish -> dish.getCalories() < 320)
                                   .collect(toList());
```

#### DROPWHILE

* takeWhile과 정반대로, **데이터가 정렬되어 있고, 특정 조건이 거짓이 나오면 반복 작업을 중단**하려면 dropWhile()을 이용해 처리할 수 있다.
* 프레디케이트가 처음으로 거짓이 되는 지점까지 탐색한 후, 작업을 중단하고 해당 지점 이후의 탐색하지 않은 모든 요소를 반환한다.
* 아래 예제는 320 칼로리 이상인 메뉴만 슬라이싱한다.

```java
List<Dish> silcedMenu = specialMenu.stream()
                                   .dropWhile(dish -> dish.getCalories() < 320)
                                   .collect(toList());
```

### 스트림 축소

* 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 limit(n) 메서드를 사용할 수 있다.
* 최대 n개의 요소만을 반환할 수 있다.
* 아래는 최대 3개의 요소만을 반환하도록 하는 코드이다.

```java
List<Dish> silcedMenu = specialMenu.stream()
                                   .filter(dish -> dish.getCalories() > 300)
                                   .limit(3)
                                   .collect(toList());
```

### 요소 건너뛰기

* 처음 n개 요소를 제외한 스트림을 반환하는 skip(n) 메서드를 제공한다.
* n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 스트림이 반환된다.
* limit과 skip은 상호 보완적인 연산을 수행한다.
* 아래는 300칼로리 이상인 음식 중 처음 두 요리는 스킵하고 나머지 요리들만 반환하는 코드이다.

```java
List<Dish> silcedMenu = specialMenu.stream()
                                   .filter(dish -> dish.getCalories() > 300)
                                   .skip(2)
                                   .collect(toList());
```

## 매핑

* 특정 객체에서 특정 데이터를 선택하기 위해 매핑 작업을 수행할 수 있다.

### 스트림의 각 요소에 함수 적용하기

* 함수를 인수로 받는 map 메서드를 지원한다.
* 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다.
* 다음은 Dish 리스트를 스트림으로 순회하며 Dish의 name 필드만 추출한 리스트를 반환하는 코드이다.

```java
List<String> MenuNames = specialMenu.stream()
                                    .map(Dish::getName)
                                    .collect(toList());
```

* 다른 map 메서드를 체이닝하는 것도 가능하다.
* 다음은 Dish 리스트를 스트림으로 순회하며 name필드의 길이를 추출한 리스트를 반환하는 코드이다.

```java
List<Integer> MenuNameLengths = specialMenu.stream()
                                           .map(Dish::getName)
                                           .map(String::length)
                                           .collect(toList());
```

### 스트림 평면화

* flatMap은 각 배열을 스트림이 아니라 **스트림의 콘텐츠로 매핑**한다.
* 스트림의 각 값을 다른 스트림으로 만든 다음에, 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.
* 아래 코드의 flatMap은 단어들을 모두 알파벳 단위로 떼어낸 후 얻는 여러 개의 String\[] 배열들을 하나의 String Stream으로 모아 순회할 수 있도록 해준다.

```java
List<String> uniqueChars = words.stream()
                                .map(word -> word.split("")) // Stream<String[]>
                                .flatMap(Arrays::stream) // Stream<String>
                                .distinct()
                                .collect(toList());
```

## 검색과 매칭





## 리듀싱





## 숫자형 스트림







## 다양하게 스트림 만들기









