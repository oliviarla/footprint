# 7장: 병렬 데이터 처리와 성능

* 자바 7 이전에는 데이터를 서브 파트로 분할해 각각의 스레드로 할당하고 적절한 동기화 처리를 하고, 마지막으로 결과를 모두 합쳐야 하는 것이 개발자의 몫이었다.
* 자바 7은 포크/조인 프레임워크 기능을 통해 더 쉽게 병렬화를 수행하며 에러를 최소화할 수 있도록 한다.

## 병렬 스트림

* &#x20;각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
* 컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.

### 순차 스트림을 병렬 스트림으로 변환

*   순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다. 즉, 리듀싱 연산을 여러 청크로 나누어 병렬 수행이 가능하다.



    ```java
    public long sequentialSum(long n) {
      return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .parallel() //병렬 스트림으로 변환
        .reduce(0L, Long::sum);
      }
    ```
* parallel() 메서드와 sequential() 메서드를 사용해 병렬로 실행할 연산과 순차로 실행할 연산을 제어할 수 있다.
* 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.
* 아래의 경우 parallel() 메서드가 마지막에 호출되었으므로 파이프라인은 전체적으로 병렬로 실행된다.

```java
stream.parallel()
  .filter(...)
  .sequential()
  .map(...)
  .parallel()
  .reduce();
```

> **스레드 풀 설정**
>
> * 스트림의 parallel 메서드에서 병렬로 작업을 수행하는 스레드는 ForkJoinPool에 의해 관리된다.
> * 보통 프로세서 수에 따라 스레드 개수를 자동으로 설정하기 때문에 특별한 이유가 없으면 기본 값 사용을 권장한다.

### 스트림 성능 측정

* 병렬화를 한다고 반드시 성능이 좋아지는 것이 아니므로 직접 측정해보아야 한다.
* JMH를 사용해 작은 벤치마크를 구현할 수 있다.
  * JVM으로 실행되는 프로그램의 벤치마크 과정은 핫스팟이 바이트 코드 최적화를 위해 필요한 웜업 시간, GC로 인한 오버헤드 등으로 영향을 받기 때문에 어려운 편이다.

#### 병렬 처리 시 조심해야 할 점

* iterate()와 같이 순차적인 연산은 이전 연산의 결과에 따라 다음 함수의 입력이 달라지기 때문에 청크로 분할할 수 없다.
* 따라서 병렬 처리 시에는 IntStream.rangeClosed() 와 같이 청크로 분할이 용이한 데이터 소스를 사용해야 한다.
* 병렬화 이용 시 스트림을 재귀적으로 분할, 각 서브스트림을 서로 다른 스레드에 할당, 결과를 하나의 값으로 합치는 오버헤드가 발생한다.
* 따라서 코어 간 데이터 전송 시간보다 훨씬 오래걸리는 작업만 병렬화하는것이 바람직하다.
* 공유된 상태(누적자)를 바꾸는 알고리즘에서 제대로 동기화를 해주지 않는다면 문제가 발생하게 된다.

### 병렬 스트림 효과적으로 사용하기

* 장비의 사양과 연산의 특성 등 상황에 따라 천차만별이기 때문에 어떤 상황에서 병렬 스트림을 사용할 지에 대한 정확한 가이드는 없다.
* 확신이 서지 않을때는 순차 스트림과 병렬 스트림 구현 시의 성능을 직접 측정한다.
* 오토박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소이므로 주의해야 하며, 기본형 특화 스트림(IntStream, LongStream, DoubleStream)을  사용하는 것이 좋다.
* limit이나 findFirst처럼 요소의 순서에 의존하는 연산은 병렬 스트림에서 성능이 더 떨어진다. 스트림 요소의 순서가 상관없다면 unordered를 호출해서 비정렬된 스트림을 얻은 후 limit을 호출하는 것이 더 효율적이다.
* 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려해 **처리해야 할 요소 수가 많고 한 요소 당 처리 비용이 높다면** 병렬 스트림으로 성능을 개선할 여지가 있다.
* **소량의 데이터**에서는 병렬화 과정의 부가 비용을 상쇄하지 못하므로 병렬스트림을 쓰지 말자.
* 스트림을 구성하는 자료구조가 적절한지 확인한다.&#x20;
  * ArrayList는 요소를 탐색하지 않고도 분할할 수 있지만 LinkedList는 모든 요소를 탐색해야 분할할 수 있다.
  * range 팩토리 메서드로 만든 기본형 스트림이나 커스텀 Spliterator를 구현하면 쉽게 분해할 수 있다.
* 스트림의 특성과 파이프라인 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 병렬 처리가 가능하다. 반면 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 병렬 처리가 어려워진다.
* 최종 연산의 병합 과정 비용이 비싸다면 병렬 스트림으로 얻은 이익이 상쇄될 수 있다.

## 포크/조인 프레임워크





## Spliterator 인터페이스









