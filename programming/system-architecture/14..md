# 14. 유튜브 스트리밍

#### 필수 기능 면에서 요구사항

* 비디오 업로드/시청 기능
* 지원해야 할 클라이언트: 앱, 웹, 스마트 TV
* DAU : 5M
* 평균 소비 시간: 30분 (하루 평균 5개의 비디오)
* 다국어 지원 필요
* 모든 비디오 종류와 해상도 지원
* 암호화 필요
* 파일 크기는 1GB로 제한
* 클라우드 서비스 활용 가능

#### 품질 면에서 요구사항

* 빠른 비디오 업로드
* 원활한 비디오 재생
* 낮은 인프라 비용
* 높은 가용성과 규모 확장성, 안정성

#### 개략적 규모 추정

* 일간 능동 사용자(DAU: Daily Active User)수는 5백만(5million)
* 한 사용자는 하루에 평균 5개의 비디오를 시청
* 10%의 사용자가 하루에 1비디오 업로드
* 비디오 평균 크기는 300MB
* 비디오 저장을 위해 매일 새로 요구되는 저장 용량
  * `5백만 x 10% x 300MB = 150TB`
* CDN 비용
  * 클라우드 CDN을 통해 비디오를 서비스할 경우 CDN에서 나가는 데이터의 양에 따라 과금
  * 아마존의 클라우드프론트(CloudFront)를 CDN 솔루션으로 사용할 경우, 100% 트래픽이 미국에서 발생한다고 가정하면 **1GB당 $0.02의 요금**이 발생
  * 문제를 단순화하기 위해 비디오 스트리밍 비용 만 따지도록 하겠다.
  * 매일 발생하는 요금은 `5백만 x 5비디오 x 0.3GB x $0.02 = $150,000` 이다.

### 개략적 설계안 제시

* CDN과 BLOB 스토리지는 기존 클라우드 서비스 활용
  * 적절한 기술을 골라 설계를 마치는것이 가장 중요
  * 기술 각각의 동작 설명, 어떻게 구현할지 상세 설계할 필요는 없음
  * 직접 구현하는 것은 복잡하고 많은 비용이 들기 때문에 다른 회사의 서비스를 이용하는 것이 일반적임
* 컴포넌트 구성도

<figure><img src="../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

* CDN에 저장된 비디오를 스트리밍할 수 있는 기능
* 비디오 스트리밍 제외한 모든 요청은 API 서버가 처리
  * 피드 추천, 비디오 업로드 URL 생성, 메타데이터 DB, 캐시 갱신, 사용자 가입 등

#### 비디오 업로드 절차

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

* **메타데이터 데이터베이스**(metadata db): 비디오의 메타데이터를 보관
* **메타데이터 캐시**(metadata cache): 성능을 높이기 위해 비디오 메타데이터와 사용자 객체 (user object) 캐시
*   **원본 저장소**(original storage): 원본 비디오를 보관할 대형 이진 파일 저장소 (BLOB) 시스템

    > BLOB(Binary Large Object storage) 저장소: 이진 테이터를 하나의 개체로 보관하는 DBMS
* **트랜스코딩 서버**(transcoding server): 비디오의 포맷(MPEG, HLS 등) 변환을 담당, 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요
* **트랜스코딩 비디오 저장소**(transcoded storage): 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소다.
* **CDN**: 비디오를 캐시하는 역할 담당
* **트랜스코딩 완료 큐**: 비디오 트랜스코딩 완료 이벤트를 저장할 큐
* **트랜스코딩 완료 핸들러**: 트랜스코딩 완료 큐에서 이벤트를 꺼내 메타데이터 캐시와 DB 갱신 작업을 위한 서버들
* 비디오 업로드
  1. 원본 저장소에 비디오 업로드
  2. 원본 저장소에서 비디오 가져와 트랜스코딩 시작
  3. 비디오를 트랜스코딩 비디오 저장소에 업로드하는 동시에 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 보내 메타데이터 DB, 캐시 갱신
  4. 클라이언트에게 비디오 업로드가 완료됨을 알리기
* 비디오 메타데이터 갱신
  1. 파일 이름, 크기, 포맷 등의 정보를 API 서버로 요청
  2. 메타데이터 캐시와 데이터베이스 업데이트

#### 비디오 스트리밍 절차

* 비디오 다운로드해서 보는 것이 아닌, 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송받아 영상을 재생해야 함
*   서비스의 용례에 맞는 스트리밍 프로토콜을 잘 골라야 한다

    > 스트리밍 프로토콜: 비디오 스트리밍을 위해 데이터 전송 시 사용되는 표준화된 통신 방법, 지원하는 비디오 인코딩과 플레이어가 천차만별임
* CDN 에지 서버가 비디오 전송을 담당하도록 하여 낮은 전송 지연을 보장

### 상세 설계

#### 비디오 트랜스코딩

*   특정 단말에서 녹화된 비디오는 특정 포맷으로 저장된다. 이 비디오가 다른 단말에서 재생되려면, 호환되는 bitrate와 포맷으로 저장되어야 한다.

    > bitrate: 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지 나타내는 단위, bitrate가 높을수록 높은 성능의 컴퓨팅 파워와 빠른 인터넷 회선 속도가 필요함
* 원본 비디오는 용량이 크기 때문에 특정 포맷으로 변환이 필요
* 호환성 문제 해결을 위해 하나의 비디오를 여러 포맷으로 인코딩 필요
* 네트워크 대역폭이 충분하지 않으면 저화질, 충분하면 고화질 비디오 제공
* 비디오가 끊김없이 재생될 수 있도록 화질 자동/수동 변경 기능 제공

**인코딩 포맷**

* 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 형식을 나타낸다. 파일 확장자와 같은 의미 ex) avi, mp4
* 코덱: 비디오 압축 및 압축해제 알고리즘 ex) H.264, HEVC, ..

#### DAG 모델

* Directed Acyclic Graph, 유방향 비순환 그래프
* 컴퓨팅 자원과 시간을 많이 소모하는 비디오 트랜스코딩 작업을 단계적으로 배열하고 순차적, 병렬적으로 실행될 수 있도록 한다.
* 원본 비디오는 아래와 같이 세 부분으로 나뉜 후 작업이 적용된다.

<figure><img src="../../.gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

#### 비디오 트랜스코딩 아키텍처

<figure><img src="../../.gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>

* 전처리기
  * 비디오 분할
    * GOP(Group of Pictures) 라는 비디오 스트림 단위로 분할
    * 특정 순서로 배열된 프레임의 그룹
    * 하나의 GOP는 독립적으로 재생 가능하며 몇 초 정도의 분량임
  * DAG 그래프 생성
    * 클라이언트 프로그래머가 작성한 config 파일에 따라 생성됨
  * 데이터 캐시
    * GOP, 메타데이터를 임시저장소에 보관
* DAG 스케줄러
  * DAG 그래프 분할
  * 자원 관리자의 작업 큐에 작업 단계를 입력
  * 다운로드 작업도 분할하고 트랜스 코딩도 분할하고 하는건지 정확한 동작이 궁금하다..?
* 자원 관리자
  * 자원 배분 효과적으로 수행하는 역할 담당
  * 세 개의 큐, 작업 스케줄러로 구성됨
    * 작업 큐: 실행할 작업 보관
    * 작업 서버 큐: 작업 서버의 가용상태 보관
    * 실행 큐: 실행중인 작업과 서버 보관
    * 작업 스케줄러: (최적의 작업, 서버) 조합을 골라 작업 서버에 수행하도록 지시하고 실행 큐에 입력한다. 작업 완료되면 작업을 실행 큐에서 제거한다.
* 임시 저장소
  * 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간에 따라 어떤 시스템을 사용할 지 결정
  * 메타데이터는 메모리에 캐시해두면 좋지만, 비디오/오디오 데이터는 BLOB 저장소에 두는 것이 좋다.
  * 비디오 프로세싱이 완료되면 데이터 삭제
* 인코딩된 비디오
  * 인코딩된 최종 결과물인 비디오

### 시스템 최적화

* 시청 패턴을 분석한 후 최적화를 시도하는 것이 좋다.

#### 속도 최적화

* GOP로 분할해 비디오를 병렬 업로드

<figure><img src="../../.gitbook/assets/image (30).png" alt=""><figcaption></figcaption></figure>

* 업로드 센터를 사용자 근거리에 지정 (CDN 사용하거나 각 업로드 센터 직접 구성하거나..)
* 모든 절차를 병렬화
  * 시스템 간 결합도를 낮춰 의존성을 줄이기 위해 메시지 큐를 도입할 수 있다.
  * 이전 작업이 끝나기를 마냥 기다리지 않아도 되므로 병렬적 수행 가능

<figure><img src="../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

#### 안전성 최적화

* 미리 사인된 업로드 URL
  * 허가받은 사용자만 올바른 장소에 비디오를 업로드할 수 있도록 해야함
  * 사용자는 미리 사인된 URL 정보를 받은 후에만 해당 URL이 가리키는 위치에 비디오 업로드 가능
* 비디오 저작권 보호
  * 디지털 저작권 관리 시스템 도입, AES 암호화, 워터마크 등 활용 가능

#### 비용 최적화

* 인코딩된 결과 비디오가 CDN에 저장된다.
* CDN 비용을 낮추기 위해 long-tail 분포 활용할 수 있다. (인기있는 비디오만 대부분 시청한다는 이론)

1. 인기 있는 비디오만 CDN을 통해 재생, 그외 비디오는 비디오 서버를 통해 재생
2. 인기 없는 비디오는 인코딩 작업 줄이기, 짧은 비디오는 바로바로 인코딩해 재생 가능 (CDN 사용 감소)
3. 특정 지역에만 인기가 높은 비디오는 다른 지역에 옮길 필요 없음
4. CDN을 직접 구축하고 인터넷 서비스 제공자와 제휴 (대규모라면 가능하지만 소규모라면 어려울 것)

### 오류 처리

* 회복 가능 오류
  * 비디오 세그먼트를 트랜스코딩하다 실패하는 등의 오류는 몇번 재시도하면 해결됨
  * 복구가 어렵다면 클라이언트에게 오류 코드 반환
* 회복 불가능 오류
  * 비디오 포맷 잘못되는 등의 오류 발생 시, 작업 중단하고 클라이언트에게 오류 코드 반환
* 시스템 컴포넌트의 전형적인 오류 해결법
  * 업로드 오류: 몇회 재시도한다.
  * 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우라면 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
  * 트랜스코딩 오류: 재시도한다.
  * 전처리 오류: DAG 그래프를 재생성한다.
  * DAG 스케줄러 오류: 작업을 다시 스케줄링한다.
  * 자원 관리자 큐에 장애 발생: 사본(replica)을 이용한다.
  * 작업 서버 장애: 다른 서버에서 해당 작업을 재시도한다.
  * API 서버 장애: API 서버는 무상태 서버이므로 신규 요청은 다른 API 서버로 우회될것이다.
  * 메타데이터 캐시 서버 장애: 데이터는 다중화되어 있으므로 다른 노드에서 데이터를 여전히 가져올 수 있을 것이다. 장애가 난 캐시 서버는 새로운 것으로 교체한다.
  * 메타데이터 데이터베이스 서버 장애
    * 주 서버가 죽었다면 부 서버 가운데 하나를 주 서버로 교체한다.
    * 부 서버가 죽었다면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새것으로 교체한다.
