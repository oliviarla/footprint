# 2장: 아키텍처 개요

## 네 개의 영역

### 표현 영역

* 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 영역
* 스프링 MVC 프레임워크는 이 영역을 위한 기술에 해당한다.
* 웹 애플리케이션의 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.

### 응용 영역

* 표현 영역을 통해 사용자의 요청을 전달받아 시스템이 제공해야 할 기능을 구현한다.
* 기능 구현을 위해 도메인 영역의 도메인 모델에 로직 수행을 위임하여 사용한다.
* 아래는 응용 영역의 예시이다.

```java
public class CancelOrderService {

	@Transactional
	public void cancelOrder(String orderId) {
		Order order = findOrderById(orderId);
		if (order = = null)
			throw new OrderNotFoundException(orderId);
		order.cancel(); // 도메인 모델에 위임
	}
	...
}
```

### 도메인 영역

* 도메인의 핵심 로직을 담는 도메인 모델을 구현한다.
* 예를 들어 주문 도메인은 결제 완료, 배송지 변경, 주문 총액 계산 등의 핵심 로직을 담는다.

### 인프라스트럭처 영역

* RDBMS 연동을 처리하고 메시징 큐에 메시지를 전송/수신하는 기능을 구현하는 등 구현 기술에 관한 것을 다룬다.
* SMTP를 활용한 메일 발송 기능 구현이나 HTTP를 이용한 외부 API 호출도 처리한다.
* 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용하여 데이터를 읽어온다.

## 계층 구조 아키텍처

* 전체적인 아키텍처는 아래의 계층 구조를 따른다.

<figure><img src="../../.gitbook/assets/image (194).png" alt="" width="188"><figcaption></figcaption></figure>

* 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
* 바로 아래 계층에게만 의존하지 않고 더 아래에 있는 계층에 의존할 수도 있다.
* 응용 영역에서는 로직 구현을 위해 인프라스트럭처 영역의 클래스를 사용해야 하는 경우가 있다. 이 때 두 가지 문제가 발생하는데, 하나는 응용 영역의 테스트를 위해 인프라스트럭처 영역이 완벽히 동작해야 한다는 문제이고 다른 하나는 구현 방식을 변경하기 어렵다는 점이다.
* 아래는 할인가격 계산을 하는 응용 영역 코드가 DroolsRuleEngine이라는 외부 모듈을 사용하기 위해 인프라스트럭처 영역의 코드를 사용하는 모습이다.

<figure><img src="../../.gitbook/assets/image (195).png" alt="" width="563"><figcaption></figcaption></figure>

* 이러한 문제를 발생하지 않도록 하려면 DIP를 적용해야 한다.

## DIP

* DIP는 고수준의 모듈이 추상화된 인터페이스를 의존하게 하고, 이 인터페이스를 저수준 모듈이 구현하도록 하는 방식이다.

> 고수준 모듈은 의미있는 단일 기능을 제공하는 모듈이다. 저수준 모듈은 고수준 모듈의 하위 기능을 구현한 것이다. 예를 들어 할인 가격 계산을 해주는 고수준 모듈이 있다면, 고객이 담은 상품 목록을 읽어오는 저수준 모듈과 총 가격을 할인해주는 저수준 모듈에 의존할 것이다.

* DIP를 통해 저수준 모듈이 고수준 모듈에 의존하게 되어 **의존 역전 원칙**이라고 한다.
* 고수준의 모듈이 인터페이스를 의존하게 되면 저수준 모듈 내부의 코드를 이해할 필요가 없다. 따라서 구현 기술에 의존하지 않게 된다.
* 추상화된 인터페이스는 고수준 모듈에 속하게 된다.
* 아래는 CalculateDiscountService가 직접 DroolsRuleEngine에 의존하는 대신 인터페이스인 RuleDiscounter에 의존하는 모양을 나타낸 것이다.

<figure><img src="../../.gitbook/assets/image (196).png" alt="" width="563"><figcaption></figcaption></figure>

* DIP를 사용하면 테스트 시에 인터페이스에 mock 객체를 대입해 사용할 수 있으므로 실제 구현과 관계 없이 고수준 모듈을 쉽게 테스트할 수 있다.
* DIP는 단순히 인터페이스와 구현 클래스를 분리하는 것이 아니라, 고수준 모듈이 저수준 모듈에 의존하지 않도록 구성해야 한다.

<figure><img src="../../.gitbook/assets/image (197).png" alt="" width="563"><figcaption></figcaption></figure>

* 아래는 인터페이스를 사용하고는 있지만 도메인 영역이 인프라스트럭처 영역을 의존하는 것에는 변함이 없으므로 잘못된 구조이며 DIP를 적용한 것이 아니다.



* 응용/도메인 영역에서 인프라스트럭처의 구현이 필요하다면, 해당 영역에 인터페이스를 두고 인프라스트럭처에 인터페이스의 구현체를 두어야 DIP를 제대로 적용하는 것이다.

<figure><img src="../../.gitbook/assets/image (198).png" alt="" width="563"><figcaption></figcaption></figure>

* 계층형 구조에 DIP를 적용하면 아래와 같이 의존 구조가 변한다.

<figure><img src="../../.gitbook/assets/image (199).png" alt="" width="375"><figcaption></figcaption></figure>

* 사용하는 구현 기술에 따라 완벽한 DIP를 적용하기보다는 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 게 효과적일 때도 있다.

## 도메인 영역의 주요 구성 요소

### 엔티티

* 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다.
* Product과 같이 도메인의 고유한 개념을 표현한다.
* 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.
* 도메인 모델의 엔티티는 **데이터와 함께 도메인 기능을 제공**해준다는 점에서 DB 모델의 엔티티와 다르다. 예를 들어 주문 엔티티에서는 데이터 뿐만 아니라 배송지 주소 변경을 위한 기능을 제공한다.
* 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해 표현할 수 있다.

### 밸류

* 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다.
* 배송지 주소를 표현하기 위한 Address나 구매 금액을 위한 Money와 같은 타입이 밸류 타입이다.
* 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.
* 밸류는 가급적 불변으로 두는 것이 권장되기 때문에 엔티티의 밸류 타입 데이터를 변경할 때에도 객체 자체를 완전히 교체하는 방식이 사용된다.

```java
public class Order {

	private ShippingInfo shippingInfo;
	// ...

	private void setShippingInfo(ShippingInfo newShippingInfo) {
		if (newShippingInfo == null) throw new IllegalArgumentException();
		// 밸류 타입의 데이터를 변경할 때는 새로운 객체로 교체한다.
		this.shippingInfo = newShippingInfo;
	}
	// ...
}
```

### 애그리거트

* 도메인이 커질수록 도메인 모델이 커지고, 무수히 많은 엔티티와 밸류가 생겨나면 개발자는 전체 구조가 아닌 하나의 엔티티, 밸류에 집중할 수 있다.
* 이 때 상위 수준에서 모델을 관리하기 위해 **연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은** 애그리거트 단위를 사용한다.
* 주문이라는 도메인 개념은 ‘주문’, ‘배송지 정보’, ‘주문자’, ‘주문 목록’, ‘총 결제 금액’의 하위 모델로 구성된다. 따라서 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 ‘주문’ 애그리거트로 묶을 수 있다.
* 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다. 이를 통해 전체적인 틀에서 도메인 모델을 관리할 수 있다.
* 루트 엔티티는 군집에 속한 객체를 관리하는 엔티티로, 애그리거트에 속해있는 엔티티와 밸류 객체를 이용해 애그리거트가 구현해야 할 기능을 제공한다. 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근할 수 있다.
* 다음 구성도에서는 Order라는 루트 엔티티가 존재하며 주문과 관련된 기능을 사용하려면 반드시 루트 엔티티를 통해서만 사용해야 한다.

<figure><img src="../../.gitbook/assets/image (200).png" alt="" width="563"><figcaption></figcaption></figure>

* 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고, 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.

### 리포지토리

* 도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.
* 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
* 도메인 모델이 필요한 경우 리포지토리를 통해 도메인 객체를 얻어야 한다.
* 앞서 다뤘던 것처럼, DIP를 적용하여 리포지토리 인터페이스는 도메인 모델 영역에 속하고, 실제 구현 클래스는 인프라스트럭처 영역에 속한다.

<figure><img src="../../.gitbook/assets/image (201).png" alt="" width="375"><figcaption></figcaption></figure>

* 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지토리를 사용하고, 트랜잭션 처리 시 리포지토리의 구현 기술에 영향을 받는다.
* 리포지토리를 사용하는 주체는 응용 서비스이기 때문에 응용이 요구하는 저장/조회/삭제 메서드 등이 기본적으로 포함된다.

### 도메인 서비스

* 특정 엔티티에 속하지 않은 도메인 로직을 제공한다.
* ‘할인 금액 계산’은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.

## 요청 처리 흐름

* 사용자로부터 요청이 들어오면 표현 영역이 가장 먼저 이를 받아 응용 서비스가 요구하는 형태로 변환해 전달한다. 예를 들어 사용자가 브라우저를 통해 HTTP 요청을 보내면 표현 영역에서는 필요한 데이터만 추려 응용 서비스를 실행한다.
* 응용 서비스는 도메인 모델을 이용해 기능을 구현한다. 이 도메인 모델을 조회하거나 저장하는 것은 리포지토리를 통해 수행된다. 도메인의 상태 변경을 수행하는 경우 트랜잭션을 관리해야 한다.

<figure><img src="../../.gitbook/assets/image (202).png" alt=""><figcaption></figcaption></figure>

## 인프라스트럭처

* 스프링을 사용할 경우 응용 서비스는 트랜잭션 처리를 위해 `@Transactional` 을 사용하는 것이 편리하다. 영속성 처리를 위해 JPA를 사용하는 경우 도메인 모델에 JPA 전용 어노테이션을 사용하는 것이 편리하다.

```java
@Entity
@Table(name = “TBL_ORDER”)
public class Order {
	// ...
}
```

* 구현의 편리함은 DIP가 주는 다른 장점(변경의 유연함, 테스트가 쉬움)만큼 중요하기 때문에, DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존성을 가져도 무방하다.
* 표현 영역은 항상 인프라스트럭처 영역과 밀접한 관계를 이룬다. 웹 요청을 처리하려면 프레임워크에 맞게 표현 영역을 구현해야만 한다.

## 모듈 구성

* 아키텍처의 각 영역은 별도의 패키지를 구성하여 분리한다.
* 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 아키텍처의 각 영역을 구성한다.

<figure><img src="../../.gitbook/assets/image (203).png" alt="" width="563"><figcaption></figcaption></figure>

* 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.
* 예를 들어 카탈로그 도메인에 상품 애그리거트와 카테고리 애그리거트가 있는 경우 아래와 같이 패키지가 구성될 수 있다.

<figure><img src="../../.gitbook/assets/image (204).png" alt="" width="563"><figcaption></figcaption></figure>

* 애그리거트, 모델, 리포지터리는 domain 패키지에 위치시킨다.
* 도메인이 복잡하면 도메인 모델과 도메인 서비스를 별도 패키지에 위치시킬 수도 있다.
  * ex) com\*\*.**myshop**.**order**.**domain**.**order, com**.**myshop**.**order**.**domain**.\*\*service
* 저자는 한 패키지에 10\~15개 미만으로 타입 개수를 유지하는 것이 좋다고 한다.
